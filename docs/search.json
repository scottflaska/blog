[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Building a Strokes Gained Model for Golf\n\n\n\n\n\n\n\nshotlink\n\n\ngolf\n\n\nr\n\n\nmachine learning\n\n\n\n\n\n\n\n\n\n\n\nMay 14, 2023\n\n\nScott Flaska\n\n\n\n\n\n\n  \n\n\n\n\nDeploying R Projects with Docker\n\n\n\n\n\n\n\nr\n\n\ndocker\n\n\ndevops\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2023\n\n\nScott Flaska\n\n\n\n\n\n\n  \n\n\n\n\nExploring PGA Shotlink Data\n\n\n\n\n\n\n\nshotlink\n\n\ngolf\n\n\nr\n\n\neda\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\nScott Flaska\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 30, 2023\n\n\nScott Flaska\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a data scientist - currently working as the senior manager of football analytics for the Denver Broncos. In my current role, I collaborate with the football operations departments to design, plan, and implement projects that help improve decision-making and efficiency across the organization."
  },
  {
    "objectID": "posts/dvc/index.html",
    "href": "posts/dvc/index.html",
    "title": "DVC!",
    "section": "",
    "text": "Data Version Control (DVC) is a tool I‚Äôve found helpful for data science projects. I came across DVC while looking for a better way to manage datasets and models within our Football Technology and Research group at the Broncos. In fact, I've found it so helpful and easy to use, that I'm shocked that I don't see it discussed more frequently in some of the communities I follow online (mostly R and football analytics).\nLast May I shared a brief introduction to DVC with other NFL data scientists and software developers at our annual conference. I figured I would repost it here for anyone that might find it useful.\ndvc push"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Welcome to my blog! Hoping to post (somewhat) frequently on data science, sports analytics, and other topics."
  },
  {
    "objectID": "home.html",
    "href": "home.html",
    "title": "Home",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "DVC!\n\n\n\n\n\n\n\nversion control\n\n\ngit\n\n\ndevops\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\nScott Flaska\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 2, 2023\n\n\nScott Flaska\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/shotlink_explore/index.html",
    "href": "posts/shotlink_explore/index.html",
    "title": "Exploring PGA Shotlink Data",
    "section": "",
    "text": "Last year, I found some sample data while reading about PGA Shotlink1. I decided to put together a series of posts using this data. This first post will cover some simple data cleaning and visualization.\nThe sample contains 4 delimited text files: event-level, hole-level, round-level, and shot-level. I‚Äôll focus on the shot-level data in this post.\n\nlibrary(tidyverse)\n\n\nshot_level <- read.delim(file ='shotlink_sample/StrokeLevelTOURChamp.txt')\nstr(shot_level)\n\n'data.frame':   8422 obs. of  38 variables:\n $ tour_code                      : chr  \"R\" \"R\" \"R\" \"R\" ...\n $ tour_description               : chr  \"PGA TOUR\" \"PGA TOUR\" \"PGA TOUR\" \"PGA TOUR\" ...\n $ year                           : int  2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 ...\n $ tourn_num                      : int  410 410 410 410 410 410 410 410 410 410 ...\n $ Player..                       : int  1810 1810 1810 1810 1810 1810 1810 1810 1810 1810 ...\n $ Course..                       : int  688 688 688 688 688 688 688 688 688 688 ...\n $ Permanent.Tournament..         : int  60 60 60 60 60 60 60 60 60 60 ...\n $ Player.First.Name              : chr  \"Phil\" \"Phil\" \"Phil\" \"Phil\" ...\n $ Player.Last.Name               : chr  \"Mickelson\" \"Mickelson\" \"Mickelson\" \"Mickelson\" ...\n $ Round                          : int  1 1 1 1 1 1 1 1 1 1 ...\n $ Tournament.Name                : chr  \"TOUR Championship by Coca-Cola\" \"TOUR Championship by Coca-Cola\" \"TOUR Championship by Coca-Cola\" \"TOUR Championship by Coca-Cola\" ...\n $ Course.Name                    : chr  \"East Lake GC\" \"East Lake GC\" \"East Lake GC\" \"East Lake GC\" ...\n $ Hole                           : int  1 1 1 1 2 2 3 3 3 3 ...\n $ Hole.Score                     : int  4 4 4 4 2 2 4 4 4 4 ...\n $ Par.Value                      : int  4 4 4 4 3 3 4 4 4 4 ...\n $ Yardage                        : int  424 424 424 424 214 214 387 387 387 387 ...\n $ Shot                           : int  1 2 3 4 1 2 1 2 3 4 ...\n $ Shot.Type.S.P.D.               : chr  \"S\" \"S\" \"S\" \"S\" ...\n $ X..of.Strokes                  : int  1 1 1 1 1 1 1 1 1 1 ...\n $ From.Location.Scorer.          : chr  \"Tee Box\" \"Primary Rough\" \"Green\" \"Green\" ...\n $ From.Location.Laser.           : chr  \"\" \"Right Rough\" \"Unknown\" \"Unknown\" ...\n $ To.Location.Scorer.            : chr  \"Primary Rough\" \"Green\" \"Green\" \"\" ...\n $ To.Location.Laser.             : chr  \"Right Rough\" \"Unknown\" \"Unknown\" \"\" ...\n $ Distance                       : int  10677 4932 326 39 7727 231 10069 3309 150 14 ...\n $ Distance.to.Pin                : int  15444 4788 281 39 7812 231 13464 3440 132 14 ...\n $ In.the.Hole.Flag               : chr  \"N\" \"N\" \"N\" \"Y\" ...\n $ Around.the.Green.Flag          : chr  \"N\" \"N\" \"N\" \"N\" ...\n $ X1st.Putt.Flag                 : chr  \"\" \"\" \"Y\" \"\" ...\n $ Distance.to.Hole.after.the.Shot: int  4788 281 39 0 231 0 3440 132 14 0 ...\n $ Time                           : int  1255 1300 1304 1305 1307 1312 1315 1320 1324 1324 ...\n $ Lie                            : chr  \"Good\" \"N/A\" \"Good\" \"Good\" ...\n $ Elevation                      : chr  \"With\" \"With\" \"With\" \"With\" ...\n $ Slope                          : chr  \"Level\" \"Level\" \"Level\" \"Level\" ...\n $ X.Coordinate                   : chr  \"9,093.97\" \"8,683.75\" \"8,697.45\" \"0\" ...\n $ Y.Coordinate                   : chr  \"9,859.90\" \"9,868.71\" \"9,845.29\" \"0\" ...\n $ Z.Coordinate                   : num  480 504 504 0 491 ...\n $ Distance.from.Center           : int  562 232 33 0 214 0 127 15 2 0 ...\n $ Distance.from.Edge             : int  126 25 199 0 347 0 344 32 140 0 ...\n\n\nThis table has a ton of interesting fields to explore, but first I want to clean up the column names - the janitor package makes this really easy.\n\nshot_level_clean <- shot_level %>% \n  janitor::clean_names() %>% \n  rename(num_of_strokes = x_of_strokes,\n         first_putt_flag = x1st_putt_flag)\n\nshot_level_clean %>% \n  colnames() %>% \n  head(10) \n\n [1] \"tour_code\"            \"tour_description\"     \"year\"                \n [4] \"tourn_num\"            \"player\"               \"course\"              \n [7] \"permanent_tournament\" \"player_first_name\"    \"player_last_name\"    \n[10] \"round\"               \n\n\nNext, I‚Äôd like to get a feel for the scope of the data.\n\n#How many tournaments/rounds?\nshot_level_clean %>% \n  select(year, tournament_name, round) %>% \n  distinct()\n\n  year                tournament_name round\n1 2011 TOUR Championship by Coca-Cola     1\n2 2011 TOUR Championship by Coca-Cola     2\n3 2011 TOUR Championship by Coca-Cola     3\n4 2011 TOUR Championship by Coca-Cola     4\n\n\n\n#How many players?\nshot_level_clean %>% \n  select(player,\n         player_first_name,\n         player_last_name) %>% \n  distinct()\n\n   player player_first_name player_last_name\n1    1810              Phil        Mickelson\n2    2206             David             Toms\n3    6527             Steve         Stricker\n4    6567             Vijay            Singh\n5   20645              John           Senden\n6   21731           Fredrik         Jacobson\n7   21878              Mark           Wilson\n8   21961           Charles       Howell III\n9   22046             Geoff           Ogilvy\n10  22371             Aaron         Baddeley\n11  22405            Justin             Rose\n12  23108              Matt           Kuchar\n13  23623                Bo         Van Pelt\n14  23983              Luke           Donald\n15  24357              K.J.             Choi\n16  24502              Adam            Scott\n17  24663              Y.E.             Yang\n18  24781            Hunter            Mahan\n19  24924              Bill             Haas\n20  24925          Jonathan             Byrd\n21  25686             Jason           Dufner\n22  25804             Bubba           Watson\n23  26476              Chez           Reavie\n24  27095              Nick           Watney\n25  27649            Brandt         Snedeker\n26  28089             Jason              Day\n27  29221              Webb          Simpson\n28  30925            Dustin          Johnson\n29  31323              Gary         Woodland\n30  33141            Keegan          Bradley\n\n\n\n#Player scores?\nshot_level_clean %>% \n  group_by(player,\n           player_first_name,\n           player_last_name,\n           round) %>% \n  summarize(shots = n(),\n            .groups = \"keep\") %>% \n  ungroup() %>% \n  mutate(round = paste0(\"round_\",round)) %>% \n  pivot_wider(names_from = round,\n              values_from = shots) %>% \n  as.data.frame() %>% \n  mutate(final_score = round_1 + round_2 + round_3 + round_4) %>% \n  arrange(final_score) %>% \n  select(-player, -player_first_name) %>% \n  head()\n\n  player_last_name round_1 round_2 round_3 round_4 final_score\n1            Mahan      67      68      66      71         272\n2           Donald      66      68      70      69         273\n3             Choi      68      65      70      70         273\n4             Haas      68      67      70      68         273\n5         Baddeley      68      70      64      73         275\n6            Scott      67      65      75      68         275\n\n\nAt first glance, the data looks straightforward: one row for every stroke in the 2011 FedEx Cup Playoffs, with Hunter Mahan defeating the field of 30 with a final score of 272. However, a quick Google search shows that Bill Haas actually won the tournament in a playoff over Hunter Mahan. Referencing the docs, the number of strokes assessed actually comes from the # of Strokes2 column (renamed to num_of_strokes above) to account for drops and penalties. Adjusting the code above:\n\nshot_level_clean %>% \n  group_by(player,\n           player_first_name,\n           player_last_name,\n           round) %>% \n  summarize(shots = sum(num_of_strokes),\n            .groups = \"keep\") %>% \n  ungroup() %>% \n  mutate(round = paste0(\"round_\",round)) %>% \n  pivot_wider(names_from = round,\n              values_from = shots) %>% \n  as.data.frame() %>% \n  mutate(final_score = round_1 + round_2 + round_3 + round_4) %>% \n  arrange(final_score) %>% \n  select(-player, -player_first_name) %>% \n  head()\n\n  player_last_name round_1 round_2 round_3 round_4 final_score\n1            Mahan      67      68      66      71         272\n2             Haas      68      67      69      68         272\n3         Baddeley      68      69      64      72         273\n4           Donald      66      68      70      69         273\n5             Choi      68      65      70      70         273\n6       Howell III      67      71      68      68         274\n\n\nThese scores match the round-level scores on the Wikipedia page, which is good enough for me.\nNext - I want to take a look at the x/y/z coordinate data. The docs give definitions for these fields:\n\nThe X coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet.\nThe Y coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet.\nThe Z coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet, and ‚ÄòZ‚Äô is the vertical component of the position.\n\nThe shot that finishes in the hole will get 0 values, but these definitions don‚Äôt indicate whether the coordinates are relative to each hole or the overall course. Plotting the shots should help clear this up. Additionally, I need to convert the coordinate columns from character to numeric .\n\nlibrary(ggplot2)\n\n\nshot_level_clean %>% \n  mutate(x = str_replace_all(string = x_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>%\n  mutate(y = str_replace_all(string = y_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(z = str_replace_all(string = z_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(x = as.numeric(x),\n         y = as.numeric(y),\n         z = as.numeric(z)) %>% \n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point()\n\n\n\n\nThe non-zero shot coordinates look like a golf course, so I think it makes sense to set the 0 values to NA since the coordinates to not appear to match the grid system.\n\nshot_level_clean_coords <- shot_level_clean %>% \n  mutate(x = str_replace_all(string = x_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>%\n  mutate(y = str_replace_all(string = y_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(z = str_replace_all(string = z_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(x = as.numeric(x),\n         y = as.numeric(y),\n         z = as.numeric(z)) %>% \n  mutate(x = ifelse(x == 0,NA,x),\n         y = ifelse(y == 0,NA,y),\n         z = ifelse(z == 0,NA,z)) %>% \n  select(-x_coordinate,\n         -y_coordinate,\n         -z_coordinate)\n\nshot_level_clean_coords %>% \n  filter(!is.na(x)) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y,\n                       color = hole)) +\n  geom_point() +\n  coord_equal() +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.background = element_blank())\n\n\n\n\nDefinitely looks like a golf course, especially when you overlay it on top of the Google Maps view of East Lake Golf Club in Atlanta:\n\nNext I‚Äôd like to take a look at the cut3 information for each shot. The table has two columns with this information:\n\nTo Location (Scorer): General location from which the shot hit ended as recorded by the walking scorer\nTo Location (Laser): Enhanced location from which the shot hit ended as recorded by a laser device which tracks ball position using coordinates on a course map\n\n\nshot_level_clean_coords %>% \n  filter(!is.na(x)) %>% \n  group_by(to_location_laser,\n           to_location_scorer) %>%\n  summarize(rows = n(),\n            .groups = \"keep\") %>% \n  as.data.frame() %>% \n  arrange(desc(rows))\n\n                to_location_laser to_location_scorer rows\n1                         Unknown              Green 3548\n2                    Left Fairway            Fairway  578\n3                   Right Fairway            Fairway  550\n4                      Left Rough      Primary Rough  436\n5                     Right Rough      Primary Rough  401\n6              Right Intermediate Intermediate Rough  145\n7               Left Intermediate Intermediate Rough  112\n8                         Unknown     Fairway Bunker   92\n9         Right Green Side Bunker  Green Side Bunker   77\n10  Right Front Green Side Bunker  Green Side Bunker   66\n11   Front Left Green Side Bunker  Green Side Bunker   60\n12         Left Green Side Bunker  Green Side Bunker   47\n13 Front Center Green Side Bunker  Green Side Bunker   34\n14                        Unknown       Tree Outline   24\n15                        Unknown              Water   23\n16                        Unknown            Unknown   20\n17                        Unknown         Water Drop   13\n18    Left Rear Green Side Bunker  Green Side Bunker    3\n19                   Left Fairway             Fringe    2\n20                  Right Fairway             Fringe    2\n21   Right Rear Green Side Bunker  Green Side Bunker    1\n22                        Unknown       Dirt Outline    1\n\n\nThe columns seem to match up pretty well, but I‚Äôd like to consolidate them into a more general `to_location_cut` column.\n\nshot_level_clean_coords_cut <- shot_level_clean_coords %>% \n  mutate(to_location_cut = case_when(to_location_scorer %in% c('Fairway','Fringe') ~ 'fairway',\n                                     to_location_scorer %in% c('Fairway Bunker','Green Side Bunker') ~ 'bunker',\n                                     to_location_scorer %in% c('Intermediate Rough','Primary Rough') ~ 'rough',\n                                     to_location_scorer == 'Green' ~ 'green',\n                                     to_location_scorer == 'Water' ~ 'water',\n                                     \n                                     is.na(x) ~ 'hole',\n                                     T ~ 'other'))\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>% \n  group_by(to_location_laser,\n           to_location_scorer,\n           to_location_cut) %>%\n  summarize(rows = n(),\n            .groups = \"keep\") %>% \n  as.data.frame() %>% \n  arrange(desc(rows))\n\n                to_location_laser to_location_scorer to_location_cut rows\n1                         Unknown              Green           green 3548\n2                    Left Fairway            Fairway         fairway  578\n3                   Right Fairway            Fairway         fairway  550\n4                      Left Rough      Primary Rough           rough  436\n5                     Right Rough      Primary Rough           rough  401\n6              Right Intermediate Intermediate Rough           rough  145\n7               Left Intermediate Intermediate Rough           rough  112\n8                         Unknown     Fairway Bunker          bunker   92\n9         Right Green Side Bunker  Green Side Bunker          bunker   77\n10  Right Front Green Side Bunker  Green Side Bunker          bunker   66\n11   Front Left Green Side Bunker  Green Side Bunker          bunker   60\n12         Left Green Side Bunker  Green Side Bunker          bunker   47\n13 Front Center Green Side Bunker  Green Side Bunker          bunker   34\n14                        Unknown       Tree Outline           other   24\n15                        Unknown              Water           water   23\n16                        Unknown            Unknown           other   20\n17                        Unknown         Water Drop           other   13\n18    Left Rear Green Side Bunker  Green Side Bunker          bunker    3\n19                   Left Fairway             Fringe         fairway    2\n20                  Right Fairway             Fringe         fairway    2\n21   Right Rear Green Side Bunker  Green Side Bunker          bunker    1\n22                        Unknown       Dirt Outline           other    1\n\n\nNext - I want to plot `to_location_cut` to see how it looks.\n\ncut_colors = c('bunker'='tan',\n               'fairway'='#4CBB17',\n               'green'='#90EE90',\n               'rough'='#355E3B',\n               'other'='red',\n               'water'='lightblue')\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point(mapping = aes(color = to_location_cut),\n             size = 1) +\n  coord_equal() +\n  scale_color_manual(values = cut_colors) +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank())\n\n\n\n\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>% \n  filter(hole == 1) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point(mapping = aes(color = to_location_cut),\n             size = 2) +\n  coord_equal() +\n  scale_color_manual(values = cut_colors) +\n  labs(title = \"1st Hole\") +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank())\n\n\n\n\n\nsaveRDS(object = shot_level_clean_coords_cut, file = \"shot_level.rds\")\nsaveRDS(object = cut_colors, file = \"cut_colors.rds\")\n\n\n\n\n\nFootnotes\n\n\nThe data was available here, but it looks like it‚Äôs been moved.‚Ü©Ô∏é\n# of Strokes (1 digit numeric): The number of strokes assessed for this shot. In most cases, this will be ‚Äò1‚Äô, but it may be ‚Äò0‚Äô for a drop or ‚Äò2‚Äô for a 2-stroke penalty.‚Ü©Ô∏é\nfairway, rough, green, etc.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/01_welcome/index.html",
    "href": "posts/01_welcome/index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Welcome to my blog! Hoping to post (somewhat) frequently on data science, sports analytics, and other topics."
  },
  {
    "objectID": "posts/02_shotlink_explore/index.html",
    "href": "posts/02_shotlink_explore/index.html",
    "title": "Exploring PGA Shotlink Data",
    "section": "",
    "text": "Last year I found some sample data while reading about PGA Shotlink1. I decided to put together a series of posts using this data. This first post will cover some simple data cleaning and visualization.\nThe sample contains 4 delimited text files: event-level, hole-level, round-level, and shot-level. I‚Äôll focus on the shot-level data in this post.\n\nlibrary(tidyverse)\n\n\nshot_level <- read.delim(file ='shotlink_sample/StrokeLevelTOURChamp.txt')\nstr(shot_level, vec.len = 1)\n\n'data.frame':   8422 obs. of  38 variables:\n $ tour_code                      : chr  \"R\" ...\n $ tour_description               : chr  \"PGA TOUR\" ...\n $ year                           : int  2011 2011 ...\n $ tourn_num                      : int  410 410 ...\n $ Player..                       : int  1810 1810 ...\n $ Course..                       : int  688 688 ...\n $ Permanent.Tournament..         : int  60 60 ...\n $ Player.First.Name              : chr  \"Phil\" ...\n $ Player.Last.Name               : chr  \"Mickelson\" ...\n $ Round                          : int  1 1 ...\n $ Tournament.Name                : chr  \"TOUR Championship by Coca-Cola\" ...\n $ Course.Name                    : chr  \"East Lake GC\" ...\n $ Hole                           : int  1 1 ...\n $ Hole.Score                     : int  4 4 ...\n $ Par.Value                      : int  4 4 ...\n $ Yardage                        : int  424 424 ...\n $ Shot                           : int  1 2 ...\n $ Shot.Type.S.P.D.               : chr  \"S\" ...\n $ X..of.Strokes                  : int  1 1 ...\n $ From.Location.Scorer.          : chr  \"Tee Box\" ...\n $ From.Location.Laser.           : chr  \"\" ...\n $ To.Location.Scorer.            : chr  \"Primary Rough\" ...\n $ To.Location.Laser.             : chr  \"Right Rough\" ...\n $ Distance                       : int  10677 4932 ...\n $ Distance.to.Pin                : int  15444 4788 ...\n $ In.the.Hole.Flag               : chr  \"N\" ...\n $ Around.the.Green.Flag          : chr  \"N\" ...\n $ X1st.Putt.Flag                 : chr  \"\" ...\n $ Distance.to.Hole.after.the.Shot: int  4788 281 ...\n $ Time                           : int  1255 1300 ...\n $ Lie                            : chr  \"Good\" ...\n $ Elevation                      : chr  \"With\" ...\n $ Slope                          : chr  \"Level\" ...\n $ X.Coordinate                   : chr  \"9,093.97\" ...\n $ Y.Coordinate                   : chr  \"9,859.90\" ...\n $ Z.Coordinate                   : num  480 ...\n $ Distance.from.Center           : int  562 232 ...\n $ Distance.from.Edge             : int  126 25 ...\n\n\nThis table has a ton of interesting fields to explore, but first I want to clean up the column names - the janitor package makes this really easy.\n\nshot_level_clean <- shot_level %>% \n  janitor::clean_names() %>% \n  rename(num_of_strokes = x_of_strokes,\n         first_putt_flag = x1st_putt_flag)\n\nshot_level_clean %>% \n  colnames() %>% \n  head(10) \n\n [1] \"tour_code\"            \"tour_description\"     \"year\"                \n [4] \"tourn_num\"            \"player\"               \"course\"              \n [7] \"permanent_tournament\" \"player_first_name\"    \"player_last_name\"    \n[10] \"round\"               \n\n\nNext, I‚Äôd like to get a feel for the scope of the data.\n\n#How many tournaments/rounds?\nshot_level_clean %>% \n  select(year, tournament_name, round) %>% \n  distinct()\n\n  year                tournament_name round\n1 2011 TOUR Championship by Coca-Cola     1\n2 2011 TOUR Championship by Coca-Cola     2\n3 2011 TOUR Championship by Coca-Cola     3\n4 2011 TOUR Championship by Coca-Cola     4\n\n\n\n#How many players?\nshot_level_clean %>% \n  select(player,\n         player_first_name,\n         player_last_name) %>% \n  distinct()\n\n   player player_first_name player_last_name\n1    1810              Phil        Mickelson\n2    2206             David             Toms\n3    6527             Steve         Stricker\n4    6567             Vijay            Singh\n5   20645              John           Senden\n6   21731           Fredrik         Jacobson\n7   21878              Mark           Wilson\n8   21961           Charles       Howell III\n9   22046             Geoff           Ogilvy\n10  22371             Aaron         Baddeley\n11  22405            Justin             Rose\n12  23108              Matt           Kuchar\n13  23623                Bo         Van Pelt\n14  23983              Luke           Donald\n15  24357              K.J.             Choi\n16  24502              Adam            Scott\n17  24663              Y.E.             Yang\n18  24781            Hunter            Mahan\n19  24924              Bill             Haas\n20  24925          Jonathan             Byrd\n21  25686             Jason           Dufner\n22  25804             Bubba           Watson\n23  26476              Chez           Reavie\n24  27095              Nick           Watney\n25  27649            Brandt         Snedeker\n26  28089             Jason              Day\n27  29221              Webb          Simpson\n28  30925            Dustin          Johnson\n29  31323              Gary         Woodland\n30  33141            Keegan          Bradley\n\n\n\n#Player scores?\nshot_level_clean %>% \n  group_by(player,\n           player_first_name,\n           player_last_name,\n           round) %>% \n  summarize(shots = n(),\n            .groups = \"keep\") %>% \n  ungroup() %>% \n  mutate(round = paste0(\"round_\",round)) %>% \n  pivot_wider(names_from = round,\n              values_from = shots) %>% \n  as.data.frame() %>% \n  mutate(final_score = round_1 + round_2 + round_3 + round_4) %>% \n  arrange(final_score) %>% \n  select(-player, -player_first_name) %>% \n  head()\n\n  player_last_name round_1 round_2 round_3 round_4 final_score\n1            Mahan      67      68      66      71         272\n2           Donald      66      68      70      69         273\n3             Choi      68      65      70      70         273\n4             Haas      68      67      70      68         273\n5         Baddeley      68      70      64      73         275\n6            Scott      67      65      75      68         275\n\n\nAt first glance, the data looks straightforward: one row for every stroke in the 2011 FedEx Cup Playoffs, with Hunter Mahan defeating the field of 30 with a final score of 272. However, a quick Google search shows that Bill Haas actually won the tournament in a playoff over Hunter Mahan. Referencing the docs, the number of strokes assessed actually comes from the # of Strokes2 column (renamed to num_of_strokes above) to account for drops and penalties. Adjusting the code above:\n\nshot_level_clean %>% \n  group_by(player,\n           player_first_name,\n           player_last_name,\n           round) %>% \n  summarize(shots = sum(num_of_strokes),\n            .groups = \"keep\") %>% \n  ungroup() %>% \n  mutate(round = paste0(\"round_\",round)) %>% \n  pivot_wider(names_from = round,\n              values_from = shots) %>% \n  as.data.frame() %>% \n  mutate(final_score = round_1 + round_2 + round_3 + round_4) %>% \n  arrange(final_score) %>% \n  select(-player, -player_first_name) %>% \n  head()\n\n  player_last_name round_1 round_2 round_3 round_4 final_score\n1            Mahan      67      68      66      71         272\n2             Haas      68      67      69      68         272\n3         Baddeley      68      69      64      72         273\n4           Donald      66      68      70      69         273\n5             Choi      68      65      70      70         273\n6       Howell III      67      71      68      68         274\n\n\nThese scores match the round-level scores on the Wikipedia page, which is good enough for me.\nNext - I want to take a look at the x/y/z coordinate data. The docs give definitions for these fields:\n\nThe X coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet.\nThe Y coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet.\nThe Z coordinate in an X/Y/Z grid system used by lasers to pinpoint the ball when the shot ends. The value is zeros for the shot that finishes in the hole. The numbers in the grid system represent feet, and ‚ÄòZ‚Äô is the vertical component of the position.\n\nThe shot that finishes in the hole will get 0 values, but these definitions don‚Äôt indicate whether the coordinates are relative to each hole or the overall course. Plotting the shots should help clear this up. Additionally, I need to convert the coordinate columns from character to numeric .\n\nlibrary(ggplot2)\n\n\nshot_level_clean %>% \n  mutate(x = str_replace_all(string = x_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>%\n  mutate(y = str_replace_all(string = y_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(z = str_replace_all(string = z_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(x = as.numeric(x),\n         y = as.numeric(y),\n         z = as.numeric(z)) %>% \n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point()\n\n\n\n\nThe non-zero shot coordinates look like a golf course, so I think it makes sense to set the 0 values to NA since the coordinates to not appear to match the grid system.\n\nshot_level_clean_coords <- shot_level_clean %>% \n  mutate(x = str_replace_all(string = x_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>%\n  mutate(y = str_replace_all(string = y_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(z = str_replace_all(string = z_coordinate,\n                             pattern = \",\",\n                             replacement = \"\")) %>% \n  mutate(x = as.numeric(x),\n         y = as.numeric(y),\n         z = as.numeric(z)) %>% \n  mutate(x = ifelse(x == 0,NA,x),\n         y = ifelse(y == 0,NA,y),\n         z = ifelse(z == 0,NA,z)) %>% \n  select(-x_coordinate,\n         -y_coordinate,\n         -z_coordinate)\n\nshot_level_clean_coords %>% \n  filter(!is.na(x)) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y,\n                       color = hole)) +\n  geom_point() +\n  coord_equal() +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.background = element_blank())\n\n\n\n\nDefinitely looks like a golf course, especially when you overlay it on top of the Google Maps view of East Lake Golf Club in Atlanta:\n\nNext I‚Äôd like to take a look at the cut3 information for each shot. The table has 4 columns with this information:\n\nTo Location (Scorer): General location from which the shot hit ended as recorded by the walking scorer\nTo Location (Laser): Enhanced location from which the shot hit ended as recorded by a laser device which tracks ball position using coordinates on a course map\nFrom Location (Scorer): General location from which the shot began as recorded by the walking scorer\nFrom Location (Laser): Enhanced location from which the shot began as recorded by a laser device which tracks ball position using coordinates on a course map\n\nThe x/y coordinate data matches the ‚Äúto location‚Äù - so I‚Äôll focus on those columns for now.\n\nshot_level_clean_coords %>% \n  filter(!is.na(x)) %>% \n  group_by(to_location_laser,\n           to_location_scorer) %>%\n  summarize(rows = n(),\n            .groups = \"keep\") %>% \n  as.data.frame() %>% \n  arrange(desc(rows))\n\n                to_location_laser to_location_scorer rows\n1                         Unknown              Green 3548\n2                    Left Fairway            Fairway  578\n3                   Right Fairway            Fairway  550\n4                      Left Rough      Primary Rough  436\n5                     Right Rough      Primary Rough  401\n6              Right Intermediate Intermediate Rough  145\n7               Left Intermediate Intermediate Rough  112\n8                         Unknown     Fairway Bunker   92\n9         Right Green Side Bunker  Green Side Bunker   77\n10  Right Front Green Side Bunker  Green Side Bunker   66\n11   Front Left Green Side Bunker  Green Side Bunker   60\n12         Left Green Side Bunker  Green Side Bunker   47\n13 Front Center Green Side Bunker  Green Side Bunker   34\n14                        Unknown       Tree Outline   24\n15                        Unknown              Water   23\n16                        Unknown            Unknown   20\n17                        Unknown         Water Drop   13\n18    Left Rear Green Side Bunker  Green Side Bunker    3\n19                   Left Fairway             Fringe    2\n20                  Right Fairway             Fringe    2\n21   Right Rear Green Side Bunker  Green Side Bunker    1\n22                        Unknown       Dirt Outline    1\n\n\nThe columns seem to match up pretty well, but I‚Äôd like to consolidate them into more general to_location column.\n\nshot_level_clean_coords_cut <- shot_level_clean_coords %>% \n  mutate(to_location = case_when(to_location_scorer %in% c('Fairway','Fringe') ~ 'Fairway',\n                                     to_location_scorer %in% c('Fairway Bunker','Green Side Bunker') ~ 'Bunker',\n                                     to_location_scorer %in% c('Intermediate Rough','Primary Rough') ~ 'Rough',\n                                     to_location_scorer == 'Green' ~ 'Green',\n                                     to_location_scorer == 'Water' ~ 'Water',\n                                     distance_to_hole_after_the_shot == 0 ~ 'Hole',\n                                     T ~ 'Other'))\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>%\n  group_by(to_location_laser,\n           to_location_scorer,\n           to_location) %>%\n  summarize(rows = n(),\n            .groups = \"keep\") %>% \n  as.data.frame() %>% \n  arrange(desc(rows))\n\n                to_location_laser to_location_scorer to_location rows\n1                         Unknown              Green       Green 3548\n2                    Left Fairway            Fairway     Fairway  578\n3                   Right Fairway            Fairway     Fairway  550\n4                      Left Rough      Primary Rough       Rough  436\n5                     Right Rough      Primary Rough       Rough  401\n6              Right Intermediate Intermediate Rough       Rough  145\n7               Left Intermediate Intermediate Rough       Rough  112\n8                         Unknown     Fairway Bunker      Bunker   92\n9         Right Green Side Bunker  Green Side Bunker      Bunker   77\n10  Right Front Green Side Bunker  Green Side Bunker      Bunker   66\n11   Front Left Green Side Bunker  Green Side Bunker      Bunker   60\n12         Left Green Side Bunker  Green Side Bunker      Bunker   47\n13 Front Center Green Side Bunker  Green Side Bunker      Bunker   34\n14                        Unknown       Tree Outline       Other   24\n15                        Unknown              Water       Water   23\n16                        Unknown            Unknown       Other   20\n17                        Unknown         Water Drop       Other   13\n18    Left Rear Green Side Bunker  Green Side Bunker      Bunker    3\n19                   Left Fairway             Fringe     Fairway    2\n20                  Right Fairway             Fringe     Fairway    2\n21   Right Rear Green Side Bunker  Green Side Bunker      Bunker    1\n22                        Unknown       Dirt Outline       Other    1\n\n\nNext - I want to plot to_location to see how it looks.\n\ncut_colors = c('Bunker'='tan',\n               'Fairway'='#4CBB17',\n               'Tee Box'='#4CBB17',\n               'Green'='#90EE90',\n               'Rough'='#355E3B',\n               'Other'='darkgray',\n               'Hole'='black',\n               'Water'='lightblue')\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point(mapping = aes(color = to_location),\n             size = 1) +\n  coord_equal() +\n  scale_color_manual(values = cut_colors) +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank())\n\n\n\n\n\nshot_level_clean_coords_cut %>% \n  filter(!is.na(x)) %>% \n  filter(hole == 1) %>% \n  mutate(hole = factor(hole, ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y)) +\n  geom_point(mapping = aes(color = to_location),\n             size = 2) +\n  coord_equal() +\n  scale_color_manual(values = cut_colors) +\n  labs(title = \"1st Hole\") +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank())\n\n\n\n\nLastly, I‚Äôd like to add columns that indicate how many strokes are remaining for the player before/after each shot, since it does not appear that they are in the current data set.\n\nstrokes_remaining <- shot_level_clean_coords_cut %>% \n  group_by(player,\n           hole,\n           round) %>% \n  arrange(player,\n          round,\n          hole,\n          shot) %>% \n  mutate(strokes_rolling = cumsum(num_of_strokes)) %>% \n  mutate(strokes_remaining_before_shot = hole_score - strokes_rolling + 1,\n         strokes_remaining_after_shot = hole_score - strokes_rolling) %>%\n  ungroup() %>% \n  mutate(yards_out_after_shot = distance_to_hole_after_the_shot/36,\n         yards_out_before_shot = distance_to_pin/36) %>% \n  as.data.frame()\n\nstrokes_remaining %>% \n  filter(hole == 1,\n         round == 1,\n         player == 24924) %>% \n  select(shot,\n         strokes_rem_before = strokes_remaining_before_shot,\n         yards_out_before = yards_out_before_shot,\n         strokes_rem_after = strokes_remaining_after_shot,\n         yards_out_after = yards_out_after_shot) \n\n  shot strokes_rem_before yards_out_before strokes_rem_after yards_out_after\n1    1                  4       429.000000                 3      116.444444\n2    2                  3       116.444444                 2       10.722222\n3    3                  2        10.722222                 1        1.194444\n4    4                  1         1.194444                 0        0.000000\n\n\n\nstrokes_remaining %>% \n  filter(!is.na(x)) %>% \n  filter(hole == 1) %>% \n  mutate(strokes_remaining_after_shot = factor(strokes_remaining_after_shot, \n                                               ordered = T)) %>%\n  ggplot(mapping = aes(x = x,\n                       y = y,\n                       color = strokes_remaining_after_shot)) +\n  geom_point(size = 3) +\n  coord_equal() +\n  labs(title = \"1st Hole\") +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid = element_blank())\n\n\n\n\n\nsaveRDS(object = strokes_remaining, file = \"shot_level.rds\")\nsaveRDS(object = cut_colors, file = \"cut_colors.rds\")\n\n\n\n\n\nFootnotes\n\n\nThe data was available here, but it looks like it‚Äôs been moved.‚Ü©Ô∏é\n# of Strokes (1 digit numeric): The number of strokes assessed for this shot. In most cases, this will be ‚Äò1‚Äô, but it may be ‚Äò0‚Äô for a drop or ‚Äò2‚Äô for a 2-stroke penalty.‚Ü©Ô∏é\nfairway, rough, green, etc.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/03_rocker/index.html",
    "href": "posts/03_rocker/index.html",
    "title": "Deploying R Projects with Docker",
    "section": "",
    "text": "Overview\nSharing data science projects with stakeholders can be challenging, especially when working on smaller teams without dedicated IT/DevOps support. Through a lot of trial-and-error, I‚Äôve developed a framework that I use for most of my R projects. This framework makes it easy to collaborate with other team members and deploy web apps, reports, and APIs on-premises or in the cloud. In this post I‚Äôll outline the steps needed to get started (code here).\n\n\nInstall Docker\nThe first step is to install Docker. Docker is a platform that allows you to run applications in ‚Äúisolated‚Äù environments called containers. You can find the install instructions here.\n\n\nDockerfile\nOnce Docker is installed, you‚Äôll need to create a Dockerfile for your container. A Dockerfile is just a text file with instructions for what your environment needs to run code. These steps are usually comparable to helping a new team member get their laptop setup. Generally, you tell them what they need to install: programs, packages, database drivers, etc. A Dockerfile formalizes this process and makes it much easier to manage.\nLuckily, the folks at The Rocker Project have already done most of the heavy lifting. They provide a collection of Linux container images that you can extend for your own project. I generally use the rstudio images which come with RStudio Server already installed. These images make it easy to develop R code inside the container while it‚Äôs running.\nBelow you‚Äôll find an example of a typical Dockerfile I use. It extends the rstudio:4.2.2 image from The Rocker Project, installs and configures Shiny Server (more on that later) and installs the R packages we‚Äôll need for this example.\n\n\ndockerfile\n\nFROM rocker/rstudio:4.2.2\n\n#install shiny server\nRUN /rocker_scripts/install_shiny_server.sh\n\n#add shiny server config\nCOPY /R/shiny_server.conf /etc/shiny-server/shiny-server.conf\n\n#install R packages\nRUN R -e 'install.packages(pkgs = c(\"markdown\"))'\nRUN R -e 'install.packages(pkgs = c(\"rmarkdown\"))'\nRUN R -e 'install.packages(pkgs = c(\"plumber\"))'\n\n\n\nDocker Compose\nThe next step is installing Docker Compose. Compose provides helpful configuration options which you can define in a .yml file.\n\n\ncompose.yml\n\nversion: \"3.9\"\n\nservices:\n  blog_example:\n    build: .\n    image: blog_example\n    container_name: blog_example\n    environment:\n      - PASSWORD=blog\n      - ROOT=true\n    ports:\n      - \"8803:8787\"\n      - \"8003:8000\"\n      - \"3983:3838\"\n    restart: always\n    volumes:\n      - ./R:/home/rstudio/R\n\nThe build parameter allows you to specify the path to the Dockerfile defined above, the . indicates the Dockerfile file is in the same directory as compose.yml. The environment parameter sets the PASSWORD and root access for the Rocker Project container. The ports parameter indicates which ports to expose on the container and how to map them to the host ports (HOST:CONTAINER). This is a crucial step which can be tricky. The applications in the container, like RStudio Server and Shiny Server, operate on specific ports (8787 and 3838, respectively) which you can map to your local machine anywhere you‚Äôd like (8803 and 3983 in this example). Port management allows you to run multiple containers with different projects simultaneously. Lastly, the volumes parameter allows you to connect a directory on your local machine to a directory in the container. This enables you to edit your code locally, as well as inside the container while it‚Äôs running. Without volumes, you would need to rebuild the container every time you changed your code.\n\n\nBuild + Run Container\nNow you are ready to build and run the container, which can be done in a single command:\ndocker-compose -f compose.yml up --build -d\nTo stop the container, use:\ndocker-compose -f compose.yml down\n\n\nRStudio Server\nNavigate to http://localhost:8803/ and you should see an RStudio Server login screen. Log in with u: rstudio and p: blog. Once you‚Äôve logged in, you should see the familiar RStudio interface.\n\n\n\n\nShiny Server\nAs noted above, the Dockerfile contains a command to install Shiny Server from a script provided by The Rocker Project. Additionally, the Dockerfile overwrites the /etc/shiny-server/shiny-server.conf file with an updated config file that sets the host directory for Shiny apps to /home/rstudio/R/shiny_apps. This file path is found inside the container, you should be able to navigate to it from the file explorer in RStudio Server.\n\nAny Shiny apps added in this directory will be exposed at http://localhost:3983/. You can also add interactive R Markdown reports as Shiny apps.\n\n\nPlumber APIs\nYou can also host plumber APIs to make your R functions available as API endpoints. This is particularly helpful for making trained ML models accessible to other applications. First, create a plumber.R API script1. Next add a script that runs your new API on port 8000 (mapped to 8003 in compose.yml).\n\n\nrun.R\n\nr = plumber::plumb(\"plumber.R\")\nr$run(host=\"0.0.0.0\", port=8000, swagger=TRUE)\n\nAfter you run the script, the API documentation will be exposed at http://localhost:8003/__docs__/#/. You can execute the script in your running container from the terminal of your host machine with:\ndocker exec -dw /home/rstudio/R/api blog_example Rscript run.R\n\n\nDeploy\nThe framework above should be all you need to create reproducible environment containers for R projects. The final step is organizing the steps above into a build script that can be run on your remote host (on-premises or in the cloud). I‚Äôll try to follow-up with a more detailed post on how to do this, along with some tips and tricks for managing automated builds and CI/CD pipelines.\n\n\n\n\n\nFootnotes\n\n\nFile > New File > Plumber API‚Ä¶‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/03_rocker/index.html#add-shiny-web-apps",
    "href": "posts/03_rocker/index.html#add-shiny-web-apps",
    "title": "Deploying R Projects in Docker",
    "section": "Add Shiny web apps",
    "text": "Add Shiny web apps"
  },
  {
    "objectID": "posts/03_rocker/index.html#add-r-markdown-shiny-documents",
    "href": "posts/03_rocker/index.html#add-r-markdown-shiny-documents",
    "title": "Deploying R Projects in Docker",
    "section": "Add R Markdown Shiny documents",
    "text": "Add R Markdown Shiny documents"
  },
  {
    "objectID": "posts/03_rocker/index.html#add-shiny-web-apps-and-r-markdown-documents",
    "href": "posts/03_rocker/index.html#add-shiny-web-apps-and-r-markdown-documents",
    "title": "Deploying R Projects in Docker",
    "section": "Add Shiny web apps and R Markdown documents",
    "text": "Add Shiny web apps and R Markdown documents"
  },
  {
    "objectID": "posts/04_strokes_gained/index.html",
    "href": "posts/04_strokes_gained/index.html",
    "title": "Building a Strokes Gained Model for Golf",
    "section": "",
    "text": "Introduction\nStrokes Gained is an interesting method for evaluating golfers, co-created by Columbia Business School professor Mark Broadie.\nStrokes Gained co-creator @markbroadie illustrates the statistic using Justin Thomas' final-round eagle at the 2021 #THEPLAYERS. üîé pic.twitter.com/LJ6qnp3ooE‚Äî Golf Channel (@GolfChannel) March 8, 2023 \nFrom my understanding, Strokes Gained is similar to Expected Points Added (EPA) in football - golfers are evaluated against an ‚Äúexpected‚Äù number of strokes remaining after each shot. This ‚Äúexpected‚Äù value is based off a predictive model trained on historical data1. In this post, I‚Äôll build an expected strokes remaining model using PGA ShotLink data, which can later be used to estimate strokes gained. The model will use features in the shot-level data to predict how many strokes remaining the golfer has before the shot.\n\n\nData Preparation\nFirst, I‚Äôll load the cleaned up data from my previous post.\n\nlibrary(tidyverse)\nlibrary(tidymodels)\n\n\nshot_level <- readRDS(\"../02_shotlink_explore/shot_level.rds\")\ncut_colors <- readRDS(\"../02_shotlink_explore/cut_colors.rds\")\n\nBefore I start building a model, I want to gain a better understanding of how penalties, drops, and provisionals are handled in the data. The shot_type_s_p_d column has this information (S = Shot, P = Penalty, D = Drop, Pr = Provisional).\n\n#Filter to holes where player's had at least 1 penalty/drop/provisional\nshot_level %>% \n  mutate(is_p_d = ifelse(shot_type_s_p_d == 'S',0,1)) %>% \n  group_by(player,\n           round,\n           hole) %>% \n  mutate(p_d_count = sum(is_p_d)) %>% \n  filter(p_d_count > 0) %>% \n  ungroup() %>% \n  arrange(player,\n          round,\n          hole,\n          shot) %>% \n  select(player,\n         round,\n         hole,\n         shot,\n         type = shot_type_s_p_d,\n         strokes = num_of_strokes,\n         yards_out = yards_out_before_shot,\n         to_location) %>% \n  as.data.frame() %>% \n  head(14)\n\n   player round hole shot type strokes    yards_out to_location\n1    2206     2   18    1    S       1 238.00000000       Rough\n2    2206     2   18    2    D       0  13.16666667       Rough\n3    2206     2   18    3    S       1  15.11111111       Green\n4    2206     2   18    4    S       1   1.16666667        Hole\n5    6527     4    6    1    S       1 222.00000000       Water\n6    6527     4    6    2    P       1  20.25000000       Other\n7    6527     4    6    3    D       0  20.25000000       Other\n8    6527     4    6    4    S       1  70.11111111       Green\n9    6527     4    6    5    S       1   0.02777778        Hole\n10   6567     1    6    1    S       1 215.00000000       Water\n11   6567     1    6    2    P       1  13.27777778       Other\n12   6567     1    6    3    D       0  13.27777778       Other\n13   6567     1    6    4    S       1  73.36111111       Green\n14   6567     1    6    5    S       1   3.66666667        Hole\n\n\nReviewing the sample above, it looks like the yards_out_before_shot column (which will probably be the best predictor of strokes remaining) is a little misleading for penalty drops. For example, it looks like Player 6527 went in the water off the tee on the 6th Hole (Day 4), and had to take a penalty drop. The yards_out_before_shot value on the penalty and the drop is 20.25, but 70.11 on the first shot after the drop. This might be because ShotLink is measuring to where the ball landed in the water, but Player 6527 had to drop where they entered the penalty area. For my model, I‚Äôll filter down to actual shots, where shot_type_s_p_d = \"S\". I‚Äôll also add a shot_id so it will be easier to join back to the original data set later.\n\nshot_level <- shot_level %>%\n  arrange(player,\n          round,\n          hole,\n          shot) %>% \n  mutate(shot_id = row_number())\n\nshots <- shot_level %>% \n  filter(shot_type_s_p_d == 'S')\n\n\n\nLinear Model\nNow I‚Äôll take a look at how distance from the hole correlates to strokes remaining.\n\nshots %>% \n  ggplot(mapping = aes(x = yards_out_before_shot,\n                       y = strokes_remaining_before_shot)) +\n  geom_jitter(width = 0,\n              height = 0.1,\n              alpha = 0.25) +\n  geom_smooth(method = loess,\n              se = FALSE) +\n  scale_y_continuous(breaks = 1:10)\n\n\n\n#Calculate R-Squared\ncor(shots$yards_out_before_shot, \n    shots$strokes_remaining_before_shot)^2\n\n[1] 0.682005\n\n\nWhile there is a certainly a strong correlation between these numbers, the relationship is not quite linear. A log transformation should clean this up.\n\nshots <- shots %>% \n  mutate(log_yards_out_before_shot = log(yards_out_before_shot+1))\n  \n\nshots %>% \n  ggplot(mapping = aes(x = log_yards_out_before_shot,\n                       y = strokes_remaining_before_shot)) +\n  geom_jitter(width = 0,\n              height = 0.1,\n              alpha = 0.1) +\n  geom_smooth(method = loess,\n              se = FALSE) +\n  scale_y_continuous(breaks = 1:10)\n\n\n\n#Calculate R-Squared\ncor(shots$log_yards_out_before_shot, \n    shots$strokes_remaining_before_shot)^2\n\n[1] 0.7876248\n\n\nThe log transformation improves the R2 value, but it can probably be improved even further with a nonlinear model. To test this, I‚Äôll use cross-validation to evaluate out-of-sample performance. Ideally, I‚Äôd like to use some type of time-series data splitting here to avoid any possible data leakage issues2, but I‚Äôll use a simpler method in this post. I‚Äôll split the 30 golfers into 10 groups of 3, and hold out one of these groups in the cross-validation process.\n\nplayer_cv_groups <- shots %>% \n  select(player) %>% \n  unique() %>% \n  arrange(player) %>% \n  mutate(cv_group = cut_number(x = player, \n                               n = 10,\n                               labels = FALSE))\n\nshots <- shots %>% \n  inner_join(player_cv_groups,\n             by = \"player\")\n\nshots %>% \n  group_by(cv_group) %>% \n  summarize(golfers = n_distinct(player),\n            shots = n())\n\n# A tibble: 10 √ó 3\n   cv_group golfers shots\n      <int>   <int> <int>\n 1        1       3   834\n 2        2       3   840\n 3        3       3   832\n 4        4       3   834\n 5        5       3   820\n 6        6       3   835\n 7        7       3   839\n 8        8       3   845\n 9        9       3   834\n10       10       3   835\n\nfolds <- group_vfold_cv(data = shots,\n                        group = cv_group)\n\nNow, using these folds, I‚Äôll find a performance baseline using the linear model above.\n\njust_log_yards_recipe <- recipe(formula = strokes_remaining_before_shot ~\n                                  log_yards_out_before_shot, \n                                data = shots)\n\nlm_mod <- linear_reg(mode = \"regression\",\n                     engine = \"lm\")\n\nlm_workflow <- workflow() %>%\n  add_recipe(just_log_yards_recipe) %>%\n  add_model(lm_mod)\n\nlm_rs <- fit_resamples(object = lm_workflow,\n                       resamples = folds,\n                       control = control_resamples(save_pred = T))\n\nlm_rs %>%\n  collect_metrics() %>%\n  select(.metric,\n         mean) %>%\n  as.data.frame()\n\n  .metric      mean\n1    rmse 0.5569516\n2     rsq 0.7900181\n\n\nAs expected, the mean hold-out performance is very similar to the linear model fit on all the data.\n\n\nXGBoost Model\nNext I‚Äôll try a gradient boosted tree model using the XGBoost library. I love XGBoost. It trains and tunes relatively quickly, and you don‚Äôt usually need to worry about other tedious pre-processing steps like centering, scaling, and imputing. Since XGBoost is nonlinear, I wont need to use the log transformation, and can switch back to just using yards_out_before_shot.\n\njust_yards_recipe <- recipe(formula = strokes_remaining_before_shot ~\n                              yards_out_before_shot, \n                            data = shots)\n\nxgb_mod <- boost_tree(mode = \"regression\",\n                      engine = \"xgboost\")\n\nxgb_workflow <- workflow() %>%\n  add_recipe(just_yards_recipe) %>%\n  add_model(xgb_mod)\n\nxgb_rs <- fit_resamples(object = xgb_workflow,\n                        resamples = folds,\n                        control = control_resamples(save_pred = T))\n\nxgb_rs %>%\n  collect_metrics() %>%\n  select(.metric,\n         mean) %>%\n  as.data.frame()\n\n  .metric      mean\n1    rmse 0.5236481\n2     rsq 0.8142939\n\n\nThe XGBoost model improves performance without any parameter tuning, so hopefully I can get more out of it. First, I‚Äôll look at the out-of-sample predictions,\n\nrs_preds <- xgb_rs %>% \n  collect_predictions() %>% \n  select(row_id = .row,\n         fold = id,\n         pred = .pred)\n\npreds_join <- shots %>% \n  as.data.frame() %>% \n  mutate(row_id = row_number()) %>% \n  inner_join(rs_preds,\n             by = \"row_id\") \n\npreds_join %>% \n  ggplot(mapping = aes(x = yards_out_before_shot,\n                       y = pred,\n                       color = fold)) +\n  geom_point()\n\n\n\n\nThe fits look good, but the nonlinear warts are showing. This model only uses one feature, yards_out_before_shot, but the predictions vary significantly at the same distance. For example, looking at the shots around 200 yards out, the predictions vary from 2.8ish to 3.5ish. This will cause confusion when we start attributing strokes gained to specific shots.\n\n\nMonotonic Constraints\nLuckily, there is a fix - XGBoost has the ability to enforce monotonic constraints, meaning I can force predicted strokes remaining to increase as yards out increases. I‚Äôll retrain my model.\n\nxgb_mod <- boost_tree(mode = \"regression\") %>% \n  set_engine(engine = \"xgboost\",\n             monotone_constraints = c(1))\n\nxgb_workflow <- workflow() %>%\n  add_recipe(just_yards_recipe) %>%\n  add_model(xgb_mod)\n\nxgb_rs <- fit_resamples(object = xgb_workflow,\n                        resamples = folds,\n                        control = control_resamples(save_pred = T))\n\nxgb_rs %>%\n  collect_metrics() %>%\n  select(.metric,\n         mean) %>%\n  as.data.frame()\n\n  .metric      mean\n1    rmse 0.5201534\n2     rsq 0.8168157\n\n\nThe model performance actually improved slightly with the contraints, which is encouraging. Now I‚Äôll look at the out-of-sample predictions again.\n\nrs_preds <- xgb_rs %>% \n  collect_predictions() %>% \n  select(row_id = .row,\n         fold = id,\n         pred = .pred)\n\npreds_join <- shots %>% \n  as.data.frame() %>% \n  mutate(row_id = row_number()) %>% \n  inner_join(rs_preds,\n             by = \"row_id\") \n\npreds_join %>% \n  ggplot(mapping = aes(x = yards_out_before_shot,\n                       y = pred,\n                       color = fold)) +\n  geom_point()\n\n\n\n\nMuch better! Another interesting finding is that there is a ‚Äújump‚Äù in the predictions around 260 yards. The predicted strokes remaining jump from 3.2ish to 3.5ish. This could be because it‚Äôs near the range where PGA Tour players can take more aggressive shots at the green to reduce their score. This is a good demonstration of the value of nonlinear models.\n\n\nBall Location Features\nNext, I‚Äôd like to add some more features. I‚Äôll start with the ball location (fairway, green, etc.). I cleaned up ball location data in my last post, but those were the to_location columns. Here I need the from_location columns because I am using strokes_remaining_before_shot and yards_out_before_shot.\n\nshots %>% \n  group_by(from_location_scorer,\n           from_location_laser) %>% \n  summarize(rows = n(),\n            .groups = \"keep\") %>% \n  arrange(desc(rows)) %>% \n  as.data.frame()\n\n   from_location_scorer            from_location_laser rows\n1                 Green                        Unknown 3546\n2               Tee Box                                2162\n3               Fairway                   Left Fairway  550\n4               Fairway                  Right Fairway  533\n5         Primary Rough                     Left Rough  415\n6         Primary Rough                    Right Rough  375\n7    Intermediate Rough             Right Intermediate  144\n8    Intermediate Rough              Left Intermediate  112\n9        Fairway Bunker                        Unknown   92\n10    Green Side Bunker        Right Green Side Bunker   77\n11    Green Side Bunker  Right Front Green Side Bunker   66\n12    Green Side Bunker   Front Left Green Side Bunker   59\n13    Green Side Bunker         Left Green Side Bunker   47\n14    Green Side Bunker Front Center Green Side Bunker   34\n15               Fringe                   Left Fairway   28\n16                Other                        Unknown   20\n17        Primary Rough                        Unknown   20\n18               Fringe                  Right Fairway   18\n19          Native Area                     Left Rough   13\n20          Native Area                        Unknown   13\n21          Native Area                    Right Rough   11\n22    Green Side Bunker    Left Rear Green Side Bunker    3\n23                Other                     Left Rough    3\n24                Green                                   2\n25                Other                    Right Rough    2\n26                Water                        Unknown    2\n27    Green Side Bunker   Right Rear Green Side Bunker    1\n\nshots <- shots %>% \nmutate(from_location = case_when(from_location_scorer == 'Green' \n                                 ~ 'Green',\n                                 from_location_scorer == 'Tee Box' \n                                 ~ 'Tee Box',\n                                 from_location_scorer %in% c('Fairway',\n                                                             'Fringe') \n                                 ~ 'Fairway',\n                                 from_location_scorer %in% c('Primary Rough',\n                                                             'Intermediate Rough') \n                                 ~ 'Rough',\n                                 from_location_scorer %in% c('Fairway Bunker',\n                                                             'Green Side Bunker') \n                                 ~ 'Bunker',\n                                 TRUE \n                                 ~ 'Other')) %>% \n  mutate(from_location = factor(from_location,\n                                ordered = T,\n                                levels = c(\"Green\",\n                                           \"Fairway\",\n                                           \"Tee Box\",\n                                           \"Rough\",\n                                           \"Bunker\",\n                                           \"Other\")))\n\nshots %>% \n  filter(player == 1810,\n         round == 1,\n         hole %in% 1:3) %>%\n  select(hole,\n         shot,\n         to_location,\n         from_location) %>% \n  arrange(hole,\n          shot) %>% \n  as.data.frame()\n\n   hole shot to_location from_location\n1     1    1       Rough       Tee Box\n2     1    2       Green         Rough\n3     1    3       Green         Green\n4     1    4        Hole         Green\n5     2    1       Green       Tee Box\n6     2    2        Hole         Green\n7     3    1     Fairway       Tee Box\n8     3    2       Green       Fairway\n9     3    3       Green         Green\n10    3    4        Hole         Green\n\n\nNow I‚Äôll train a new XGBoost model with this feature. Since I‚Äôve updated the data set, I‚Äôll need to recreate the fold index and the recipe. I‚Äôll use step_dummy() to convert from_location from a factor to binary terms for each location type.\n\nfolds <- group_vfold_cv(data = shots,\n                        group = cv_group)\n\nwith_location_recipe <- recipe(formula = strokes_remaining_before_shot ~\n                                 yards_out_before_shot +\n                                 from_location,\n                               data = shots) %>% \n  step_dummy(from_location)\n\nxgb_mod <- boost_tree() %>% \n  set_mode(\"regression\") %>% \n  set_engine(\"xgboost\",\n             monotone_constraints = c(1)) %>% \n  translate()\n\nxgb_workflow <- workflow() %>%\n  add_recipe(with_location_recipe) %>%\n  add_model(xgb_mod)\n\nxgb_rs <- fit_resamples(object = xgb_workflow,\n                        resamples = folds,\n                        control = control_resamples(save_pred = T))\n\nxgb_rs %>%\n  collect_metrics() %>%\n  select(.metric,\n         mean) %>%\n  as.data.frame()\n\n  .metric      mean\n1    rmse 0.5124754\n2     rsq 0.8221943\n\n\nNot much of an improvement, but the model got a little better.\n\nrs_preds <- xgb_rs %>% \n  collect_predictions() %>% \n  select(row_id = .row,\n         fold = id,\n         pred = .pred)\n\npreds_join <- shots %>% \n  as.data.frame() %>% \n  mutate(row_id = row_number()) %>% \n  inner_join(rs_preds,\n             by = \"row_id\") \n\npreds_join %>% \n  ggplot(mapping = aes(x = yards_out_before_shot,\n                       y = pred,\n                       color = from_location)) +\n  geom_point() +\n  scale_color_manual(values = cut_colors) + \n  labs(title = \"Out-Of-Sample Predicted Strokes Remaining\")\n\n\n\n\nThese new predictions make sense. Shots from the rough/bunker are harder and thus the predicted strokes remaining are higher. For example, at 100 yards, being in the rough (vs.¬†fairway) increases expected strokes from 2.7ish to 3.0ish.\nAdding these features increased the prediction ‚Äúnoise‚Äù at each distance - similar to the results of the unconstrained XGBoost model. This stems from the variation in how each sub-model handles the new features, and it goes away if I filter down to a single hold out set (Fold 1).\n\npreds_join %>% \n  filter(fold == 'Resample01') %>% \n  ggplot(mapping = aes(x = yards_out_before_shot,\n                       y = pred,\n                       color = from_location)) +\n  geom_point() +\n  scale_color_manual(values = cut_colors) + \n  labs(title = \"Out-Of-Sample Predicted Strokes Remaining\",\n       subtitle = \"Fold 1\")\n\n\n\n\nI could probably improve model performance with some parameter tuning, but I‚Äôll stop here for now.\n\n\n\n\n\nFootnotes\n\n\nThese methods have a major shortcoming in that they attribute the entire residual to a single golfer (or the teams involved). This could probably be corrected with a hierarchical/mixed model, but I‚Äôll save that for a future post.‚Ü©Ô∏é\nIf I wanted to use this model to predict strokes remaining for future shot‚Äôs, I would want to make sure I‚Äôm not using future shots when training/evaluating my model.‚Ü©Ô∏é"
  }
]